metric = 'ROC',
na.action = na.pass)
assign(paste("gbmFit",j,sep = ""), gbmFit, envir = .GlobalEnv)
}
plot(gbmFit1)
plot(gbmFit, plotType = 'level')
plot(gbmFit1, plotType = 'level')
str(gbmFit1)
plot(gbmFit1, plotType = 'level')
gbmFit1$results
gbmFit2$results
gbmFit3$results
gbmFit$results
j = 4
clusts = c(4, 5,7,9)
j=1
all9c$b.inv.log<- as.factor(cutree(fit, k= clusts[j]))
# set seeds
set.seed(123)
seeds <- vector(mode = "list", length = 51)
for(i in 1:50) seeds[[i]] <- sample.int(1000, 22)
## For the last model:
seeds[[51]] <- sample.int(1000, 1)
#create test train
sample<- sample(1:nrow(all9c), 2/3*nrow(all9c), replace=F)
train<- all9c[sample,]
test<- all9c[-sample,]
# first tune shrinkage and number of trees
train2<- train
train2$b.rpdol<- as.factor(train2$b.rpdol)
levels(train2$b.rpdol)[levels(train2$b.rpdol)=="0"] <- "profit"
levels(train2$b.rpdol)[levels(train2$b.rpdol)=="1"] <- "loss"
formula<- "b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log +
client.totinv.log + pc.majpos.log + Billing.Type + majority.pos + Business"
cv.Control <- trainControl(method = "cv",
number = 5,
seeds= seeds
, summaryFunction=twoClassSummary,
classProbs=TRUE
)
gbmGrid <- expand.grid(shrinkage = c(0.001),
n.trees = c(10000), interaction.depth = c(5),
n.minobsinnode = c(20))
summary(all9c$b.inv.log)
set.seed(2)
j=4
gbmFit <- train(as.formula(formula), data= train2,
method = "gbm", trControl = cv.Control, verbose = FALSE,
bag.fraction = 0.5, tuneGrid = gbmGrid,
metric = 'ROC',
na.action = na.pass)
j
assign(paste("gbmFit",j,sep = ""), gbmFit, envir = .GlobalEnv)
gbmFit4$results
AUCs = c(gbmFit4$results$ROC, gbmFit4$results$ROC, gbmFit4$results$ROC, gbmFit4$results$ROC)
AUCs
plot = data.frame(no.clusts = clusts, AUC = AUCs)
plot
ggplot(plot, aes(x = no.clusts, y = AUC)) + geom_line()
clusts
plot
ggplot(plot, aes(x = no.clusts %>% as.numeric, y = AUC)) + geom_line()
plot
AUCs = c(gbmFit4$results$ROCgbmFit1$results$ROC, gbmFit2$results$ROC, gbmFit3$results$ROC)
plot = data.frame(no.clusts = clusts, AUC = AUCs)
ggplot(plot, aes(x = no.clusts %>% as.numeric, y = AUC)) + geom_line()
AUCs = c(gbmFit4$results$ROC, gbmFit1$results$ROC, gbmFit2$results$ROC, gbmFit3$results$ROC)
plot = data.frame(no.clusts = clusts, AUC = AUCs)
ggplot(plot, aes(x = no.clusts %>% as.numeric, y = AUC)) + geom_line()
gbmFit1$results$ROC
x<- dist(all9c$inv.mlsto.log, method = 'euclidean')
fit<- hclust(x, method = 'ward.D2')
plot(fit)
rect.hclust(fit, k = 5)
plot(fit)
rect.hclust(fit, k = 5)
plot(fit)
rect.hclust(fit, k = 5)
all9c$b.inv.log<- as.factor(cutree(fit, k=5))
head(all9c$b.inv.log)
key = all9c %>% group_by(b.inv.log) %>% summarise(min = min(inv.mlsto.log) %>% exp() %>% round(0), max = max(inv.mlsto.log) %>% exp() %>% round(0))
key
arrange(key, min)
key$min %>% round(-2)
breaks = c(100,600,2500,8000,60000, 1800000)
breaks = sort(breaks)
log(breaks)
man.clust<- function(first.vec=all9c$timespan.cbrt, breaks.man=c(0,4.16,6.558,15),
labs = c("t0_70", "t70_280", "t280_")){
final = cut(first.vec, breaks=breaks.man, include.lowest=TRUE, labels= labs)
return(final)
}
all9c$b.inv.log <- man.clust(first.vec=all9c$inv.mlsto.log,
breaks.man= log(breaks),
labs = c("100-600","600-2.5k","2.5k-8k","8k-60k","60k-1.8m"
))
set.seed(123)
seeds <- vector(mode = "list", length = 51)
for(i in 1:50) seeds[[i]] <- sample.int(1000, 22)
## For the last model:
seeds[[51]] <- sample.int(1000, 1)
#create test train
sample<- sample(1:nrow(all9c), 2/3*nrow(all9c), replace=F)
train<- all9c[sample,]
test<- all9c[-sample,]
# first tune shrinkage and number of trees
train2<- train
train2$b.rpdol<- as.factor(train2$b.rpdol)
levels(train2$b.rpdol)[levels(train2$b.rpdol)=="0"] <- "profit"
levels(train2$b.rpdol)[levels(train2$b.rpdol)=="1"] <- "loss"
formula<- "b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log +
client.totinv.log + pc.majpos.log + Billing.Type + majority.pos + Business"
cv.Control <- trainControl(method = "cv",
number = 5,
seeds= seeds
, summaryFunction=twoClassSummary,
classProbs=TRUE
)
gbmGrid <- expand.grid(shrinkage = c(0.001),
n.trees = c(10000), interaction.depth = c(3,4,5,6),
n.minobsinnode = c(20))
set.seed(2)
gbmFit <- train(as.formula(formula), data= train2,
method = "gbm", trControl = cv.Control, verbose = FALSE,
bag.fraction = 0.5, tuneGrid = gbmGrid,
metric = 'ROC',
na.action = na.pass)
plot(gbmFit)
write.csv(all9c, 'C:/Users/n9232371/Documents/Consultbusiness/data/all9c.csv')
summary(all9c$b.inv.log)
write.csv(all9c, 'C:/Users/n9232371/OneDrive/shared files/Bligh Tanner/masters/data/all9c.csv')
?rainbow
rainbow(5)
summary(mtcars)
summary(iris)
ggplot(all9c, aes(x = b.inv.log)) + geom_bar(stat = "bin", fill = rainbow(5))
ggplot(all9c, aes(x = b.inv.log)) + geom_bar(stat = "count", fill = rainbow(5))
?rainbow
ggplot(all9c, aes(x = b.inv.log)) + geom_bar(stat = "count", fill = terrain.colours(5))
ggplot(all9c, aes(x = b.inv.log)) + geom_bar(stat = "count", fill = terrain.colors(5))
ggplot(all9c, aes(x = b.inv.log)) + geom_bar(stat = "count", fill = topo.colors(5))
ggplot(all9c, aes(x = b.inv.log)) + geom_bar(stat = "count", fill = heat.colors(5))
ggplot(all9c, aes(x = b.inv.log)) + geom_bar(stat = "count", fill = cm.colors(5))
data.frame(cow = c('pow', 'wow', 'now', 'plow', 'cow'))
cow = data.frame(cow = c('pow', 'wow', 'now', 'plow', 'cow'))
ggplot(cow, aes(x = cow)) + geom_bar(stat = "count", fill = rainbow(5))
ggplot(cow, aes(x = cow)) + geom_bar(stat = "count", fill = terrain.colors(5))
ggplot(cow, aes(x = cow)) + geom_bar(stat = "count", fill = topo.colors(5))
ggplot(cow, aes(x = cow)) + geom_bar(stat = "count", fill = heat.colors(5))
ggplot(cow, aes(x = cow)) + geom_bar(stat = "count", fill = cm.colors(5))
ggplot(cow, aes(x = cow)) + geom_bar(stat = "count", fill = topo.colors(5))
?append
df = all9c
str(all9c)
head(df$f.rpdol)
df$f.rpdol <- as.factor(df$b.rpdol)
levels(df$f.rpdol)[levels(df$f.rpdol) == "0"] <- "profit"
levels(df$f.rpdol)[levels(df$f.rpdol) == "1"] <- "loss"
#set up 10 fold cv using caret function
folds <- createFolds(df$f.rpdol, k = 10, list = T, returnTrain = F)
str(folds)
mult = 2
if(mult > 1){
for(k in 2:mult){
set.seed(sample(1:1000,1))
folds.temp = createFolds(df$f.rpdol, k = 10, list = T, returnTrain = F)
folds = append(folds, folds.temp)
}
}
str(folds)
length(folds)
nrow(all9c)
names(all9c)
test.roc <- function(dfs = df.list, seed = 100, mtrys = c(4,5,3,4,4), method = "log", x.folds = 5,
extra.var = NULL, mult = 1){
auc<- rep(list(rep(0, length(dfs))), length(dfs))
colours <- topo.colors(5)
for(i in 1:length(dfs)){
df = get(df.list[i])
# mlsto is spinning errors, get rid of
df = df[, !(names(df) %in% 'mlsto')]
set.seed(seed)
# create f.rpdol
df$f.rpdol <- as.factor(df$b.rpdol)
levels(df$f.rpdol)[levels(df$f.rpdol) == "0"] <- "profit"
levels(df$f.rpdol)[levels(df$f.rpdol) == "1"] <- "loss"
#set up 10 fold cv using caret function
folds <- createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
#now have folds[[1]] through folds[[10]] list of rows to exclude
if(mult > 1){
for(k in 2:mult){
set.seed(sample(1:1000,1))
folds.temp = createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
folds = append(folds, folds.temp)
}
}
#if extra.var not found in names(df), change to NULL
if(!is.null(extra.var)){
if(!(extra.var %in% names(df))) extra.var = NULL
}
#define formula for algorith methods, either rf, log, boost
if(nrow(df) == 2364){
if(is.null(extra.var)){
formula <-"f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second + Billing.Type"
} else {
formula<- paste("f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second", "+", extra.var, sep = " ")
}
} else{
if(nrow(df) <= 2300){
# include code.client, code.contact, Billing.Type
formula<- "f.rpdol ~ . -Year -b.rpdol -inv.mlsto.log - return.pdol - timespan.cbrt - mlsto"
}
}
if(method %in% 'boost') {
#no JD.Second
formula <-"b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log"
}
#for loop for each fold
for (j in 1:length(folds)) {
#turn predictors and response into 'ordered' variables for roc() to work
test<- df[folds[[j]],]
levels(test$f.rpdol) <- c('profit', 'loss')
test$f.rpdol <- ordered(test$f.rpdol)
if(method %in% 'rf'){
fit <- randomForest(as.formula(formula), data = df[-folds[[j]],],
mtry = mtrys[i], ntree = 1000)
pred <- predict(fit, test, type = "prob")
pred <- pred[,2]
} else {
if(method %in% 'log'){
fit<- glm(as.formula(formula),
data = df[-folds[[j]],], family = binomial())
pred <- predict(fit, test,
type = "response")
} else {
fit <- gbm(as.formula(formula), data = df[-folds[[j]],],
distribution = "bernoulli", n.trees = 10000,
shrinkage = 0.001, interaction.depth = 5,
n.minobsinnode = 20)
pred <-predict(fit, test,
n.tree = 10000, type = "response")
}
}
#pROC
pred.p <- roc(test$f.rpdol, pred)
if (i == 1 & j== 1) {
plot.roc(pred.p, col = colours[i], print.thres = F)
} else{
plot.roc(
pred.p, col = colours[i], add = TRUE , print.thres = F)
}
auc[[i]][j]<- auc(pred.p)
#print j value
cat(j, " ")
}
print(i)
}
assign("auc.func", auc, envir = .GlobalEnv)
assign("formula", formula, envir = .GlobalEnv)
}
library(pROC)
df.list<- c('all9c')
df.list<- c('all9c')
test.roc(dfs = df.list, seed = 100, mtrys = c(5), method = "boost",
extra.var = NULL, mult = 1, x.folds = 5)
dfs = df.list
seed = 100
mtrys = c(5)
method = "boost"
extra.var = NULL
mult = 1
x.folds = 5
auc<- rep(list(rep(0, length(dfs))), length(dfs))
colours <- topo.colors(5)
i=1
df = get(df.list[i])
# mlsto is spinning errors, get rid of
df = df[, !(names(df) %in% 'mlsto')]
set.seed(seed)
# create f.rpdol
df$f.rpdol <- as.factor(df$b.rpdol)
levels(df$f.rpdol)[levels(df$f.rpdol) == "0"] <- "profit"
levels(df$f.rpdol)[levels(df$f.rpdol) == "1"] <- "loss"
#set up 10 fold cv using caret function
folds <- createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
#now have folds[[1]] through folds[[10]] list of rows to exclude
if(mult > 1){
for(k in 2:mult){
set.seed(sample(1:1000,1))
folds.temp = createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
folds = append(folds, folds.temp)
}
}
length(folds)
if(!is.null(extra.var)){
if(!(extra.var %in% names(df))) extra.var = NULL
}
nrow(df) == 2364
if(is.null(extra.var)){
formula <-"f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second + Billing.Type"
} else {
formula<- paste("f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second", "+", extra.var, sep = " ")
}
} else{
method %in% 'boost'
if(method %in% 'boost') {
#no JD.Second
formula <-"b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log"
}
j=1
test<- df[folds[[j]],]
levels(test$f.rpdol) <- c('profit', 'loss')
test$f.rpdol <- ordered(test$f.rpdol)
fit <- gbm(as.formula(formula), data = df[-folds[[j]],],
distribution = "bernoulli", n.trees = 10000,
shrinkage = 0.001, interaction.depth = 5,
n.minobsinnode = 20)
pred <-predict(fit, test,
n.tree = 10000, type = "response")
pred.p <- roc(test$f.rpdol, pred)
i == 1 & j== 1
plot.roc(pred.p, col = colours[i], print.thres = F)
head(pred)
pred.p <- pROC::roc(test$f.rpdol, pred)
plot.roc(pred.p, col = colours[i], print.thres = F)
auc(pred.p)
test.roc <- function(dfs = df.list, seed = 100, mtrys = c(4,5,3,4,4), method = "log", x.folds = 5,
extra.var = NULL, mult = 1){
auc<- rep(list(rep(0, length(dfs))), length(dfs))
colours <- topo.colors(x.folds)
for(i in 1:length(dfs)){
df = get(df.list[i])
# mlsto is spinning errors, get rid of
df = df[, !(names(df) %in% 'mlsto')]
set.seed(seed)
# create f.rpdol
df$f.rpdol <- as.factor(df$b.rpdol)
levels(df$f.rpdol)[levels(df$f.rpdol) == "0"] <- "profit"
levels(df$f.rpdol)[levels(df$f.rpdol) == "1"] <- "loss"
#set up 10 fold cv using caret function
folds <- createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
#now have folds[[1]] through folds[[10]] list of rows to exclude
if(mult > 1){
for(k in 2:mult){
set.seed(sample(1:1000,1))
folds.temp = createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
folds = append(folds, folds.temp)
}
}
#if extra.var not found in names(df), change to NULL
if(!is.null(extra.var)){
if(!(extra.var %in% names(df))) extra.var = NULL
}
#define formula for algorith methods, either rf, log, boost
if(nrow(df) == 2364){
if(is.null(extra.var)){
formula <-"f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second + Billing.Type"
} else {
formula<- paste("f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second", "+", extra.var, sep = " ")
}
} else{
if(nrow(df) <= 2300){
# include code.client, code.contact, Billing.Type
formula<- "f.rpdol ~ . -Year -b.rpdol -inv.mlsto.log - return.pdol - timespan.cbrt - mlsto"
}
}
if(method %in% 'boost') {
#no JD.Second
formula <-"b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log"
}
#for loop for each fold
for (j in 1:length(folds)) {
#turn predictors and response into 'ordered' variables for roc() to work
test<- df[folds[[j]],]
levels(test$f.rpdol) <- c('profit', 'loss')
test$f.rpdol <- ordered(test$f.rpdol)
if(method %in% 'rf'){
fit <- randomForest(as.formula(formula), data = df[-folds[[j]],],
mtry = mtrys[i], ntree = 1000)
pred <- predict(fit, test, type = "prob")
pred <- pred[,2]
} else {
if(method %in% 'log'){
fit<- glm(as.formula(formula),
data = df[-folds[[j]],], family = binomial())
pred <- predict(fit, test,
type = "response")
} else {
fit <- gbm(as.formula(formula), data = df[-folds[[j]],],
distribution = "bernoulli", n.trees = 10000,
shrinkage = 0.001, interaction.depth = 5,
n.minobsinnode = 20)
pred <-predict(fit, test,
n.tree = 10000, type = "response")
}
}
#pROC
pred.p <- pROC::roc(test$f.rpdol, pred)
if (i == 1 & j== 1) {
plot.roc(pred.p, col = colours[i], print.thres = F)
} else{
plot.roc(
pred.p, col = colours[i], add = TRUE , print.thres = F)
}
auc[[i]][j]<- auc(pred.p)
#print j value
cat(j, " ")
}
print(i)
}
assign("auc.func", auc, envir = .GlobalEnv)
assign("formula", formula, envir = .GlobalEnv)
}
df.list<- c('all9c')
test.roc(dfs = df.list, seed = 100, mtrys = c(5), method = "boost",
extra.var = NULL, mult = 1, x.folds = 5)
auc.func
auc.func %>% mean
auc.func[[1]] %>% mean
test.roc <- function(dfs = df.list, seed = 100, mtrys = c(4,5,3,4,4), method = "log", x.folds = 5,
extra.var = NULL, mult = 1){
auc<- rep(list(rep(0, length(dfs))), length(dfs))
colours <- topo.colors(x.folds*mult)
for(i in 1:length(dfs)){
df = get(df.list[i])
# mlsto is spinning errors, get rid of
df = df[, !(names(df) %in% 'mlsto')]
set.seed(seed)
# create f.rpdol
df$f.rpdol <- as.factor(df$b.rpdol)
levels(df$f.rpdol)[levels(df$f.rpdol) == "0"] <- "profit"
levels(df$f.rpdol)[levels(df$f.rpdol) == "1"] <- "loss"
#set up 10 fold cv using caret function
folds <- createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
#now have folds[[1]] through folds[[10]] list of rows to exclude
if(mult > 1){
for(k in 2:mult){
set.seed(sample(1:1000,1))
folds.temp = createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
folds = append(folds, folds.temp)
}
}
#if extra.var not found in names(df), change to NULL
if(!is.null(extra.var)){
if(!(extra.var %in% names(df))) extra.var = NULL
}
#define formula for algorith methods, either rf, log, boost
if(nrow(df) == 2364){
if(is.null(extra.var)){
formula <-"f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second + Billing.Type"
} else {
formula<- paste("f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second", "+", extra.var, sep = " ")
}
} else{
if(nrow(df) <= 2300){
# include code.client, code.contact, Billing.Type
formula<- "f.rpdol ~ . -Year -b.rpdol -inv.mlsto.log - return.pdol - timespan.cbrt - mlsto"
}
}
if(method %in% 'boost') {
#no JD.Second
formula <-"b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log"
}
#for loop for each fold
for (j in 1:length(folds)) {
#turn predictors and response into 'ordered' variables for roc() to work
test<- df[folds[[j]],]
levels(test$f.rpdol) <- c('profit', 'loss')
test$f.rpdol <- ordered(test$f.rpdol)
if(method %in% 'rf'){
fit <- randomForest(as.formula(formula), data = df[-folds[[j]],],
mtry = mtrys[i], ntree = 1000)
pred <- predict(fit, test, type = "prob")
pred <- pred[,2]
} else {
if(method %in% 'log'){
fit<- glm(as.formula(formula),
data = df[-folds[[j]],], family = binomial())
pred <- predict(fit, test,
type = "response")
} else {
fit <- gbm(as.formula(formula), data = df[-folds[[j]],],
distribution = "bernoulli", n.trees = 10000,
shrinkage = 0.001, interaction.depth = 5,
n.minobsinnode = 20)
pred <-predict(fit, test,
n.tree = 10000, type = "response")
}
}
#pROC
pred.p <- pROC::roc(test$f.rpdol, pred)
if (i == 1 & j== 1) {
plot.roc(pred.p, col = colours[i], print.thres = F)
} else{
plot.roc(
pred.p, col = colours[j], add = TRUE , print.thres = F)
}
auc[[i]][j]<- auc(pred.p)
#print j value
cat(j, " ")
}
print(i)
}
assign("auc.func", auc, envir = .GlobalEnv)
assign("formula", formula, envir = .GlobalEnv)
}
test.roc(dfs = df.list, seed = 100, mtrys = c(5), method = "boost",
extra.var = NULL, mult = 1, x.folds = 5)
test.roc(dfs = df.list, seed = 100, mtrys = c(5), method = "boost",
extra.var = NULL, mult = 1, x.folds = 10)
mean(auc.func[[1]])
auc.func
