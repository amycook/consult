levels(df$f.rpdol)[levels(df$f.rpdol) == "1"] <- "loss"
#set up 10 fold cv using caret function
folds <- createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
#now have folds[[1]] through folds[[10]] list of rows to exclude
if(mult > 1){
for(k in 2:mult){
set.seed(sample(1:1000,1))
folds.temp = createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
folds = append(folds, folds.temp)
}
}
#if extra.var not found in names(df), change to NULL
if(!is.null(extra.var)){
if(!(extra.var %in% names(df))) extra.var = NULL
}
#define formula for algorith methods, either rf, log, boost
if(nrow(df) == 2364){
if(is.null(extra.var)){
formula <-"f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second + Billing.Type"
} else {
formula<- paste("f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second", "+", extra.var, sep = " ")
}
} else{
if(nrow(df) <= 2300){
# include code.client, code.contact, Billing.Type
formula<- "f.rpdol ~ . -Year -b.rpdol "
}
}
if(method %in% 'boost') {
#no JD.Second
formula <-"b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log"
}
if(method %in% 'naiive') {
formula<- "b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + inv.mlsto.log + client.totinv.log + Business + majority.pos + JD.Second + pc.majpos.log + Billing.Type + JD.Second"
}
#for loop for each fold
for (j in 1:length(folds)) {
#turn predictors and response into 'ordered' variables for roc() to work
test<- df[folds[[j]],]
levels(test$f.rpdol) <- c('profit', 'loss')
test$f.rpdol <- ordered(test$f.rpdol)
if(method %in% 'rf'){
fit <- randomForest(as.formula(formula), data = df[-folds[[j]],],
mtry = mtrys[i], ntree = 1000)
pred <- predict(fit, test, type = "prob")
pred <- pred[,2]
}
if(method %in% 'log'){
fit<- glm(as.formula(formula),
data = df[-folds[[j]],], family = binomial())
pred <- predict(fit, test,
type = "response")
}
if(method %in% 'boost'){
fit <- gbm(as.formula(formula), data = df[-folds[[j]],],
distribution = "bernoulli", n.trees = 10000,
shrinkage = 0.001, interaction.depth = 5,
n.minobsinnode = 20)                                                                 pred <-predict(fit, test, n.tree = 10000, type = "response")
}
if(method %in% 'naiive'){
fit<- naiveBayes( as.formula(formula), df[-folds[[j]],])
pred <- predict(fit, test, type = 'raw')
pred<- pred[,2]
}
#pROC
pred.p <- pROC::roc(test$f.rpdol, pred)
if (i == 1 & j== 1) {
plot.roc(pred.p, col = colours[i], print.thres = F)
} else{
plot.roc(
pred.p, col = colours[j], add = TRUE , print.thres = F)
}
auc[[i]][j]<- auc(pred.p)
names(auc)[[i]] = method
#print j value
cat(j, " ")
}
print(i)
}
assign("auc.func", auc, envir = .GlobalEnv)
assign("formula", formula, envir = .GlobalEnv)
}
?gbm
dfs = c('all9c')
seed = 100
mtrys = c(5)
method = "boost"
extra.var = NULL
mult = 4
x.folds = 5
auc<- rep(list(rep(0, length(dfs))), length(dfs))
colours <- topo.colors(x.folds*mult)
i=1
df = get(dfs[i])
# mlsto is spinning errors, get rid of
df = df[, !(names(df) %in% 'mlsto')]
set.seed(seed)
# create f.rpdol
df$f.rpdol <- as.factor(df$b.rpdol)
levels(df$f.rpdol)[levels(df$f.rpdol) == "0"] <- "profit"
levels(df$f.rpdol)[levels(df$f.rpdol) == "1"] <- "loss"
#set up 10 fold cv using caret function
folds <- createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
#now have folds[[1]] through folds[[10]] list of rows to exclude
if(mult > 1){
for(k in 2:mult){
set.seed(sample(1:1000,1))
folds.temp = createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
folds = append(folds, folds.temp)
}
}
#if extra.var not found in names(df), change to NULL
if(!is.null(extra.var)){
if(!(extra.var %in% names(df))) extra.var = NULL
}
#define formula for algorith methods, either rf, log, boost
if(nrow(df) == 2364){
if(is.null(extra.var)){
formula <-"f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second + Billing.Type"
} else {
formula<- paste("f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second", "+", extra.var, sep = " ")
}
} else{
if(nrow(df) <= 2300){
# include code.client, code.contact, Billing.Type
formula<- "f.rpdol ~ . -Year -b.rpdol "
}
}
if(method %in% 'boost') {
#no JD.Second
formula <-"b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log"
}
if(method %in% 'naiive') {
formula<- "b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + inv.mlsto.log + client.totinv.log + Business + majority.pos + JD.Second + pc.majpos.log + Billing.Type + JD.Second"
}
#for loop for each fold
formula
j=1
test<- df[folds[[j]],]
levels(test$f.rpdol) <- c('profit', 'loss')
test$f.rpdol <- ordered(test$f.rpdol)
if(method %in% 'rf'){
fit <- randomForest(as.formula(formula), data = df[-folds[[j]],],
mtry = mtrys[i], ntree = 1000)
pred <- predict(fit, test, type = "prob")
pred <- pred[,2]
}
if(method %in% 'log'){
fit<- glm(as.formula(formula),
data = df[-folds[[j]],], family = binomial())
pred <- predict(fit, test,
type = "response")
}
if(method %in% 'boost'){
fit <- gbm(as.formula(formula), data = df[-folds[[j]],],
distribution = "bernoulli", n.trees = 10000,
shrinkage = 0.001, interaction.depth = 5,
n.minobsinnode = 20)                                                                 pred <- predict(fit, test, n.tree = 10000, type = "response")
}
fit <- gbm(as.formula(formula), data = df[-folds[[j]],],
distribution = "bernoulli", n.trees = 10000,
shrinkage = 0.001, interaction.depth = 5,
n.minobsinnode = 20)                                                                 pred <- predict(fit, test, n.tree = 10000, type = "response")
fit <- gbm(as.formula(formula), data = df[-folds[[j]],],
distribution = "bernoulli", n.trees = 10000,
shrinkage = 0.001, interaction.depth = 5,
n.minobsinnode = 20)
test.roc <- function(dfs = df.list, seed = 100, mtrys = c(4,5,3,4,4), method = "log", x.folds = 5,
extra.var = NULL, mult = 1){
auc<- rep(list(rep(0, length(dfs))), length(dfs))
colours <- topo.colors(x.folds*mult)
for(i in 1:length(dfs)){
df = get(dfs[i])
# mlsto is spinning errors, get rid of
df = df[, !(names(df) %in% 'mlsto')]
set.seed(seed)
# create f.rpdol
df$f.rpdol <- as.factor(df$b.rpdol)
levels(df$f.rpdol)[levels(df$f.rpdol) == "0"] <- "profit"
levels(df$f.rpdol)[levels(df$f.rpdol) == "1"] <- "loss"
#set up 10 fold cv using caret function
folds <- createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
#now have folds[[1]] through folds[[10]] list of rows to exclude
if(mult > 1){
for(k in 2:mult){
set.seed(sample(1:1000,1))
folds.temp = createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
folds = append(folds, folds.temp)
}
}
#if extra.var not found in names(df), change to NULL
if(!is.null(extra.var)){
if(!(extra.var %in% names(df))) extra.var = NULL
}
#define formula for algorith methods, either rf, log, boost
if(nrow(df) == 2364){
if(is.null(extra.var)){
formula <-"f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second + Billing.Type"
} else {
formula<- paste("f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second", "+", extra.var, sep = " ")
}
} else{
if(nrow(df) <= 2300){
# include code.client, code.contact, Billing.Type
formula<- "f.rpdol ~ . -Year -b.rpdol "
}
}
if(method %in% 'boost') {
#no JD.Second
formula <-"b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log"
}
if(method %in% 'naiive') {
formula<- "b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + inv.mlsto.log + client.totinv.log + Business + majority.pos + JD.Second + pc.majpos.log + Billing.Type + JD.Second"
}
#for loop for each fold
for (j in 1:length(folds)) {
#turn predictors and response into 'ordered' variables for roc() to work
test<- df[folds[[j]],]
levels(test$f.rpdol) <- c('profit', 'loss')
test$f.rpdol <- ordered(test$f.rpdol)
if(method %in% 'rf'){
fit <- randomForest(as.formula(formula), data = df[-folds[[j]],],
mtry = mtrys[i], ntree = 1000)
pred <- predict(fit, test, type = "prob")
pred <- pred[,2]
}
if(method %in% 'log'){
fit<- glm(as.formula(formula),
data = df[-folds[[j]],], family = binomial())
pred <- predict(fit, test,
type = "response")
}
if(method %in% 'boost'){
fit <- gbm(as.formula(formula), data = df[-folds[[j]],],
distribution = "bernoulli", n.trees = 10000,
shrinkage = 0.001, interaction.depth = 5,
n.minobsinnode = 20)
pred <- predict(fit, test, n.tree = 10000, type = "response")
}
if(method %in% 'naiive'){
fit<- naiveBayes( as.formula(formula), df[-folds[[j]],])
pred <- predict(fit, test, type = 'raw')
pred<- pred[,2]
}
#pROC
pred.p <- pROC::roc(test$f.rpdol, pred)
if (i == 1 & j== 1) {
plot.roc(pred.p, col = colours[i], print.thres = F)
} else{
plot.roc(
pred.p, col = colours[j], add = TRUE , print.thres = F)
}
auc[[i]][j]<- auc(pred.p)
names(auc)[[i]] = method
#print j value
cat(j, " ")
}
print(i)
}
assign("auc.func", auc, envir = .GlobalEnv)
assign("formula", formula, envir = .GlobalEnv)
}
test.roc(dfs = c('all9c'), seed = 100, mtrys = c(4), method = "naiive",
extra.var = NULL, mult = 4, x.folds = 5)
tot.auc = append(tot.auc,auc.func)
tot.auc
ggplot(melt(tot.auc), aes(x= factor(L1), y= value)) + geom_boxplot() + geom_point() +
stat_summary(fun.y="mean", geom="point", colour = "red")
index = c(1,3,4)
ns = NULL
for(i in seq_along(index)){
temp = n.samples(data = tot.auc[c(2, index[i])], type.calc = 'two.sample', alt = 'two.sided')
ns[i] = temp
}
ns
ggplot(melt(tot.auc), aes(x= factor(L1), y= value)) + geom_violin() + geom_point() +
stat_summary(fun.y="mean", geom="point", colour = "red")
ggplot(melt(tot.auc), aes(x= factor(L1), y= value)) + geom_violin() + geom_jitter() +
stat_summary(fun.y="mean", geom="point", colour = "red")
test.roc(dfs = c('all10a'), seed = 100, mtrys = c(5), method = "log",
extra.var = NULL, mult = 10, x.folds = 10)
tot.auc = auc.func
test.roc(dfs = c('all9c'), seed = 100, mtrys = c(5), method = "boost",
extra.var = NULL, mult = 10, x.folds = 10)
tot.auc = append(tot.auc,auc.func)
test.roc(dfs = c('all10c'), seed = 100, mtrys = c(4), method = "rf",
extra.var = NULL, mult = 10, x.folds = 10)
tot.auc = append(tot.auc,auc.func)
test.roc(dfs = c('all9c'), seed = 100, mtrys = c(4), method = "naiive",
extra.var = NULL, mult = 10, x.folds = 10)
tot.auc = append(tot.auc,auc.func)
ggplot(melt(tot.auc), aes(x= factor(L1), y= value)) + geom_violin() + geom_jitter() +
stat_summary(fun.y="mean", geom="point", colour = "red")
saveRDS(tot.auc,"~/Documents/github/consult/finalwriteup/report_data")
?saveRDS
saveRDS(tot.auc,"~/Documents/github/consult/finalwriteup/report_data/reduc_df_auc.rds")
library("plyr")
library("dplyr")
library('magrittr')
library('reshape2')
library('ggplot2')
library('gbm')
library('caret')
library('pROC')
library('e1071')
library('randomForest')
library('party')
library("plyr")
library("dplyr")
library('magrittr')
library('reshape2')
library('ggplot2')
library('gbm')
library('caret')
library('pROC')
library('e1071')
library('randomForest')
library('party')
setwd("~/OneDrive/shared files/Bligh Tanner/masters/data")
library('mice')
install.packages("mice")
library(mice)
names(all9c)
all9c$b.rpdol<- as.factor(all9c$b.rpdol)
all9c[,c(1:4,6:10,12:14,16)] %>% names
new <- mice(all9c[,c(1:4,6,8:10,12:14,16,18,19)], meth = 'rf')
all10mice <- complete(new)
summary(all10mice)
summary(all9c$b.rpdol)
all10mice<- cbind(all10mice, all9c[,names(all9c) %in% c('code.client', 'code.contact', 'mlsto',
'b.rpdol')])
getwd()
write.csv(all10mice, '~/OneDrive/shared files/Bligh Tanner/masters/data/all10mice_May16.csv')
all10mice_f = read.csv('~/OneDrive/shared files/Bligh Tanner/masters/data/all10mice_May16.csv')
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(5), method = "log",
extra.var = NULL, mult = 10, x.folds = 10)
tot.auc.m = auc.func
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(5), method = "log",
extra.var = NULL, mult = 10, x.folds = 10)
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(5), method = "log",
extra.var = NULL, mult = 10, x.folds = 10)
test.roc <- function(dfs = df.list, seed = 100, mtrys = c(4,5,3,4,4), method = "log", x.folds = 5,
extra.var = NULL, mult = 1){
auc<- rep(list(rep(0, length(dfs))), length(dfs))
colours <- topo.colors(x.folds*mult)
for(i in 1:length(dfs)){
df = get(dfs[i])
# mlsto is spinning errors, get rid of
df = df[, !(names(df) %in% 'mlsto')]
set.seed(seed)
# create f.rpdol
df$f.rpdol <- as.factor(df$b.rpdol)
levels(df$f.rpdol)[levels(df$f.rpdol) == "0"] <- "profit"
levels(df$f.rpdol)[levels(df$f.rpdol) == "1"] <- "loss"
#set up 10 fold cv using caret function
folds <- createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
#now have folds[[1]] through folds[[10]] list of rows to exclude
if(mult > 1){
for(k in 2:mult){
set.seed(sample(1:1000,1))
folds.temp = createFolds(df$f.rpdol, k = x.folds, list = T, returnTrain = F)
folds = append(folds, folds.temp)
}
}
#if extra.var not found in names(df), change to NULL
if(!is.null(extra.var)){
if(!(extra.var %in% names(df))) extra.var = NULL
}
#define formula for algorith methods, either rf, log, boost
if(nrow(df) == 2364){
if(is.null(extra.var)){
formula <-"f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second + Billing.Type"
} else {
formula<- paste("f.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log + JD.Second", "+", extra.var, sep = " ")
}
} else{
if(nrow(df) <= 2300){
# include code.client, code.contact, Billing.Type
formula<- "f.rpdol ~ . -Year -b.rpdol "
}
}
if(method %in% 'boost') {
#no JD.Second
formula <-"b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + b.inv.log + client.totinv.log + Business + majority.pos + pc.majpos.log"
}
if(method %in% 'naiive') {
formula<- "b.rpdol ~ Discipline + pc.pro + b.timespan.cbrt + no.users + inv.mlsto.log + client.totinv.log + Business + majority.pos + JD.Second + pc.majpos.log + Billing.Type + JD.Second"
}
#for loop for each fold
for (j in 1:length(folds)) {
#turn predictors and response into 'ordered' variables for roc() to work
test<- df[folds[[j]],]
levels(test$f.rpdol) <- c('profit', 'loss')
test$f.rpdol <- ordered(test$f.rpdol)
if(method %in% 'rf'){
fit <- randomForest(as.formula(formula), data = df[-folds[[j]],],
mtry = mtrys[i], ntree = 1000)
pred <- predict(fit, test, type = "prob")
pred <- pred[,2]
}
if(method %in% 'log'){
fit<- glm(as.formula(formula),
data = df[-folds[[j]],], family = binomial())
pred <- predict(fit, test,
type = "response")
}
if(method %in% 'boost'){
fit <- gbm(as.formula(formula), data = df[-folds[[j]],],
distribution = "bernoulli", n.trees = 10000,
shrinkage = 0.001, interaction.depth = 5,
n.minobsinnode = 20)
pred <- predict(fit, test, n.tree = 10000, type = "response")
}
if(method %in% 'naiive'){
fit<- naiveBayes( as.formula(formula), df[-folds[[j]],])
pred <- predict(fit, test, type = 'raw')
pred<- pred[,2]
}
#pROC
pred.p <- pROC::roc(test$f.rpdol, pred)
if (i == 1 & j== 1) {
plot.roc(pred.p, col = colours[i], print.thres = F)
} else{
plot.roc(
pred.p, col = colours[j], add = TRUE , print.thres = F)
}
auc[[i]][j]<- auc(pred.p)
names(auc)[[i]] = method
#print j value
cat(j, " ")
}
print(i)
}
assign("auc.func", auc, envir = .GlobalEnv)
assign("formula", formula, envir = .GlobalEnv)
}
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(5), method = "log",
extra.var = NULL, mult = 4, x.folds = 5)
test.roc <- function(dfs = df.list, seed = 100, mtrys = c(4,5,3,4,4), method = "log", x.folds = 5,
library(pROC)
library(pROC)
auc.func
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(5), method = "log",
extra.var = NULL, mult = 4, x.folds = 5)
tot.auc.m = auc.func
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(5), method = "boost",
extra.var = NULL, mult = 4, x.folds = 5)
tot.auc.m = append(tot.auc.m,auc.func)
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(4), method = "rf",
extra.var = NULL, mult = 4, x.folds = 5)
tot.auc.m = append(tot.auc.m,auc.func)
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(4), method = "naiive",
extra.var = NULL, mult = 4, x.folds = 5)
tot.auc.m = append(tot.auc.m,auc.func)
ggplot(melt(tot.auc.m), aes(x= factor(L1), y= value)) + geom_violin() + geom_jitter() +
stat_summary(fun.y="mean", geom="point", colour = "red")
index = c(1,3,4)
for(i in seq_along(index)){
ns = NULL
ns = NULL
for(i in seq_along(index)){
temp = n.samples(data = tot.auc.m[c(2, index[i])], type.calc = 'two.sample', alt = 'two.sided')
ns[i] = temp
}
library(pwr)
n.samples = function(data = results.core$diff, type.calc = 'one.sample', alt = 'greater'){
if(type.calc == 'one.sample'){
d.calc = abs(mean(data))/sd(data)
pow_pow = pwr.t.test(n = NULL, d = d.calc , sig.level = 0.05, power = .8, type = c(type.calc), alternative = alt)
return(ceiling(pow_pow$n))
}
if(type.calc == 'two.sample'){
d.calc = abs(mean(data[[1]]) - mean(data[[2]]))/sqrt(mean(c(var(data[[1]]), var(data[[2]]))))
pow_pow = pwr.t.test(n = NULL, d = d.calc , sig.level = 0.05, power = .8, type = c(type.calc), alternative = 'two.sided')
return(ceiling(pow_pow$n))
}
}
ns = NULL
for(i in seq_along(index)){
temp = n.samples(data = tot.auc.m[c(2, index[i])], type.calc = 'two.sample', alt = 'two.sided')
ns[i] = temp
}
ns
tot.auc.m
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(5), method = "log",
extra.var = NULL, mult = 10, x.folds = 10)
tot.auc.m = auc.func
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(5), method = "boost",
extra.var = NULL, mult = 10, x.folds = 10)
tot.auc.m = append(tot.auc.m,auc.func)
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(4), method = "rf",
extra.var = NULL, mult = 10, x.folds = 10)
tot.auc.m = append(tot.auc.m,auc.func)
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(4), method = "naiive",
extra.var = NULL, mult = 10, x.folds = 10)
tot.auc.m = append(tot.auc.m,auc.func)
tot.auc.m
tot.auc.m <- tot.auc.m[1:2]
tot.auc.m
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(4), method = "rf",
extra.var = NULL, mult = 10, x.folds = 10)
tot.auc.m = append(tot.auc.m,auc.func)
test.roc(dfs = c('all10mice_f'), seed = 100, mtrys = c(4), method = "naiive",
extra.var = NULL, mult = 10, x.folds = 10)
ggplot(melt(tot.auc.m), aes(x= factor(L1), y= value)) + geom_violin() + geom_jitter() +
stat_summary(fun.y="mean", geom="point", colour = "red")
tot.auc.m = append(tot.auc.m,auc.func)
ggplot(melt(tot.auc.m), aes(x= factor(L1), y= value)) + geom_violin() + geom_jitter() +
stat_summary(fun.y="mean", geom="point", colour = "red")
saveRDS(tot.auc.m,"~/Documents/github/consult/finalwriteup/report_data/mice_df_auc.rds")
ggplot(melt(tot.auc.m), aes(x= factor(L1), y= value)) + geom_violin() + geom_jitter() +
stat_summary(fun.y="mean", geom="point", colour = "red")
